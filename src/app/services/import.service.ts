import { Injectable } from '@angular/core';
import * as XLSX from 'xlsx';
import { TopicService } from './topic.service';
import { Prompt } from '../data/prompt.data';
import {getModelByString, Model} from "../data/model.data";
import {Response} from "../data/response.data";
import { Rating } from '../data/rating.data';
import {CriteriaService} from "./criteria.service";

@Injectable({
  providedIn: 'root'
})
export class ImportService {


  constructor(private topicService: TopicService,
              private criteriaService: CriteriaService) { }

  public importExcel(file: File) {
    const reader: FileReader = new FileReader();

    reader.onload = (e: any) => {
      const bstr: string = e.target.result;
      const wb: XLSX.WorkBook = XLSX.read(bstr, { type: 'binary' });

      const sheetNames: string[] = wb.SheetNames;
      sheetNames.forEach(sheetName => {
        const ws: XLSX.WorkSheet = wb.Sheets[sheetName];

        /* save the data from each sheet */
        const sheetData: string[][] = XLSX.utils.sheet_to_json(ws, { header: 1 });

        let topicName = sheetName;
        let prompts: Prompt[] = [];

        let headerIndex = sheetData.findIndex(row => { return row.length > 0 && row[0] == "Prompts"});
        const detailRows = sheetData.slice(0, headerIndex-1);

        if (headerIndex > 0 && sheetData.length > headerIndex+1) {

          const headers2 = sheetData.at(headerIndex+1)!
          const responseModels: Model[] = this.extractModels(headers2);

          const promptData: string[][] = sheetData.slice(headerIndex+2);
          promptData.forEach((data) => {
            let generatedBy = getModelByString(data[1]);
            let prompt: Prompt = { request: data[0], generatedBy: generatedBy || "by_user", responses: new Map<Model, Response>()}
            responseModels.forEach(model => {
              let modelIndex = headers2.findIndex(h => h == model);
              let response: Response = {response: data[modelIndex], generatedBy: model, ratings: this.extractRatingsForModel(headers2, data, modelIndex, detailRows)}
              prompt.responses.set(model, response);
            });
            prompts.push(prompt);
          });
        }

        this.topicService.addTopic({name: topicName, prompts});
      });

    };

    reader.readAsBinaryString(file);
  }

  private extractModels(headers: string[]): Model[] {
    return headers.map(header => getModelByString(header)).filter(m => m != undefined);
  }

  private extractRatingsForModel(headers: string[], data:string[], responseIndex: number, detailRows: string[][]): Rating[] {
    let result: Rating[] = [];
    let index = responseIndex;
    let criteriaList = this.criteriaService.getCriteria();

    while(getModelByString(headers[index+1]) == undefined && headers[index+1] != undefined) {
      let label = headers[index+1];
      if (label.endsWith(" Rating")) {
        let criteriaName = label.replace(" Rating", "");
        let criteria = criteriaList.find(c => c.name == criteriaName);
        if (criteria == undefined) {
          console.log("Criteria in Headers is not registered, but will be added");
          let desc = this.extractRatingDesc(criteriaName, detailRows);
          criteria = { name: criteriaName, desc};
          this.criteriaService.addCriteria(criteriaName, desc);
        }
        let ratingModel = getModelByString(data[index+3]);
        if (ratingModel == undefined) {
          console.log("Rating was not generated by a supported model!");
        } else {
          let rating: Rating = {
            rating: +data[index + 1],
            explanation: data[index + 2],
            ratedBy: ratingModel,
            criteria: criteria
          }
          result.push(rating);
        }
        index = index+3;
      } else {
        console.log("Headers are corrupted");
      }
    }
    return result;
  }

  private extractRatingDesc(criteria: string, rows: string[][]) {
    let criteriaRow = rows.find(row => row.length > 2 && row[0]=="Criteria:" && row[1]==criteria);
    if (criteriaRow) {
      return criteriaRow[2];
    }
    return "added by user's excel without description";
  }

}
