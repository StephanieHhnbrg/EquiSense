import { Injectable } from '@angular/core';
import * as XLSX from 'xlsx';
import { TopicService } from './topic.service';
import { Prompt } from '../data/prompt.data';
import {getModelByString, Model} from "../data/model.data";
import {Response} from "../data/response.data";
import {Criteria, CRITERIA_LIST} from '../data/criteria.data';
import { Rating } from '../data/rating.data';

@Injectable({
  providedIn: 'root'
})
export class ImportService {


  constructor(private topicService: TopicService) { }

  public importExcel(file: File) {
    const reader: FileReader = new FileReader();

    reader.onload = (e: any) => {
      const bstr: string = e.target.result;
      const wb: XLSX.WorkBook = XLSX.read(bstr, { type: 'binary' });

      const sheetNames: string[] = wb.SheetNames;
      sheetNames.forEach(sheetName => {
        const ws: XLSX.WorkSheet = wb.Sheets[sheetName];

        /* save the data from each sheet */
        const sheetData: string[][] = XLSX.utils.sheet_to_json(ws, { header: 1 });

        let topicName = sheetName;
        let prompts: Prompt[] = [];

        let headerIndex = sheetData.findIndex(row => { return row.length > 0 && row[0] == "Prompt"});

        if (headerIndex > 0 && sheetData.length > headerIndex+1) {
          const headers2 = sheetData.at(headerIndex+1)!
          const responseModels: Model[] = this.extractModels(headers2);

          const promptData: string[][] = sheetData.slice(headerIndex+2);
          promptData.forEach((data) => {
            let generatedBy = getModelByString(data[1]);
            let prompt: Prompt = { request: data[0], generatedBy: generatedBy || "by_user", responses: new Map<Model, Response>()}
            responseModels.forEach(model => {
              let modelIndex = headers2.findIndex(h => h == model);
              let response: Response = {response: data[modelIndex], generatedBy: model, ratings: this.extractRatingsForModel(headers2, data, modelIndex)}
              prompt.responses.set(model, response);
            });
            prompts.push(prompt);
          });
        }

        this.topicService.addTopic({name: topicName, prompts});
      });

    };

    reader.readAsBinaryString(file);
  }

  private extractModels(headers: string[]): Model[] {
    return headers.map(header => getModelByString(header)).filter(m => m != undefined);
  }

  private extractRatingsForModel(headers: string[], data:string[], responseIndex: number): Rating[] {
    let result: Rating[] = [];
    let index = responseIndex;

    while(getModelByString(headers[index+1]) == undefined && headers[index+1] != undefined) {
      let label = headers[index+1];
      if (label.endsWith(" Rating")) {
        let criteriaName = label.replace(" Rating", "");
        let criteria = CRITERIA_LIST.find(c => c.name == criteriaName);
        if (criteria == undefined) {
          console.log("Criteria in Headers is not registered, but will be added");}
          criteria = { name: criteriaName, desc: "added by user's excel"};

        let ratingModel = getModelByString(data[index+3]);
        if (ratingModel == undefined) {
          console.log("Rating was not generated by a supported model!");
        } else {
          let rating: Rating = {
            rating: +data[index + 1],
            explanation: data[index + 2],
            ratedBy: ratingModel,
            criteria: criteria
          }
          result.push(rating);
        }
        index = index+3;
      } else {
        console.log("Headers are corrupted");
      }
    }
    return result;
  }

}
